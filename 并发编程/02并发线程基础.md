### 一、并发基础

#### 1.什么是进程和线程？

进程：运行着的程序，作为操作系统分配资源的基本单位。

线程：进程的执行实体，真正运行在CPU上的执行单元，作为操作系统调度资源的基本单位。

我们启动一个Java程序，就是创建一个Java进程；在一个进程中可以创建多个线程，每个线程各自独立拥有计数器、堆栈和局部变量属性，并且能够访问共享变量。

#### 2.线程优先级

操作系统采用时间片的形式，将系统资源分配给线程使用。当线程给定的时间片消耗完了，不论任务是否执行完，系统资源会切换到另一个线程，开始执行。

而线程优先级一定程度影响了给线程分配多少时间片，Java线程可以通过setPriority()方法来设置优先级，默认是5，设置范围是：1～10。更高优先级会有更多时间片，也会执行更多任务，所以：频繁阻塞的线程应该设置更高的优先级，耗费CPU严重的适当降低线程优先级。

（1）频繁阻塞的线程

这些线程会频繁地进入阻塞状态，导致不占用太多CPU时间。但为了让它们在解除阻塞后能够更快地获取CPU时间，适当提高优先级是一个合理的做法。例如，可以将优先级设置为6或7。

```java
Thread ioThread = new Thread(() -> {
    // 执行IO操作
});
ioThread.setPriority(Thread.NORM_PRIORITY + 1);  // 设置为普通优先级以上
```

（2）计算密集型线程

这些线程会长时间占用CPU。如果不限制其优先级，可能会导致其他线程（尤其是I/O线程）得不到足够的时间片。因此，可以适当降低此类线程的优先级，使得其他线程也能更好地执行。例如，将优先级设置为4或以下。

```java
Thread computeThread = new Thread(() -> {
    // 执行复杂计算
});
computeThread.setPriority(Thread.NORM_PRIORITY - 1);  // 设置为普通优先级以下
```

#### 3.线程的几种状态

![image-20241026215529353](https://typora-xubang.oss-cn-hangzhou.aliyuncs.com/2024_xubang/image-20241026215529353.png?AI_make_money=VX_AI19858122061)

![image-20241026215544526](https://typora-xubang.oss-cn-hangzhou.aliyuncs.com/2024_xubang/image-20241026215544526.png?AI_make_money=VX_AI19858122061)

#### 4.线程的构造方式

##### （1）继承Thread类

定义一个类继承Thread，并重写run方法，run方法其实就是线程具体执行的任务。实例化类对象，然后：start启动，join等待，sleep睡眠。

```java
public class MyThread extends Thread {
    private String taskName;

    // 构造器，用于接收线程的任务名称
    public MyThread(String taskName) {
        this.taskName = taskName;
    }

    @Override
    public void run() {
        System.out.println(taskName + " - 开始执行任务");
        // 模拟任务执行，例如打印1到5的数字
        for (int i = 1; i <= 5; i++) {
            System.out.println(taskName + " - 计数: " + i);
            try {
                // 每次计数暂停500毫秒，模拟任务耗时
                Thread.sleep(500);
            } catch (InterruptedException e) {
                System.out.println(taskName + " - 线程被中断");
                e.printStackTrace();
            }
        }
        System.out.println(taskName + " - 任务执行完毕");
    }

    public static void main(String[] args) {
        // 创建多个线程实例
        MyThread thread1 = new MyThread("线程1");
        MyThread thread2 = new MyThread("线程2");
        MyThread thread3 = new MyThread("线程3");

        // 启动线程
        thread1.start();
        thread2.start();
        thread3.start();

        // 主线程等待所有子线程完成
        try {
            thread1.join();
            thread2.join();
            thread3.join();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println("所有线程任务已完成");
    }
}
```

![image-20241026222253327](https://typora-xubang.oss-cn-hangzhou.aliyuncs.com/2024_xubang/image-20241026222253327.png?AI_make_money=VX_AI19858122061)

为什么线程的打印顺序是无序状态？

首先，多个线程可能并行在多个CPU核心上，所以会导致多个线程的顺序不可控。其次，每一个线程执行中分配的时间片以及优先级不同，也会导致多个线程的顺序不可控。

怎么保证线程执行的有序性呢？

```java
public class OrderedThreadDemo {
    public static void main(String[] args) throws InterruptedException {
        Thread thread1 = new Thread(() -> System.out.println("Thread 1 executed"));
        Thread thread2 = new Thread(() -> System.out.println("Thread 2 executed"));
        Thread thread3 = new Thread(() -> System.out.println("Thread 3 executed"));

        // 依次启动
        thread1.start();
        thread1.join(); // 等待 thread1 执行完毕

        thread2.start();
        thread2.join(); // 等待 thread2 执行完毕

        thread3.start();
        thread3.join(); // 等待 thread3 执行完毕
    }
}
```

##### （2）实现Runnable接口

​	1.创建一个类并实现 Runnable 接口。

​	2.在类中重写 run() 方法，定义线程执行的任务。

​	3.创建这个类的实例，将该实例作为参数传递给 Thread 对象。

​	4.使用 Thread 对象调用 start() 方法启动线程。

```java
package com.zdf.flowsvr.test;
// 1. 实现Runnable接口的类
class RunnableThread implements Runnable {
    // 2. 重写run()方法，定义线程要执行的任务
    @Override
    public void run() {
        // 在线程中执行的任务
        for (int i = 0; i < 5; i++) {
            System.out.println(Thread.currentThread().getName() + " 正在执行，i = " + i);
            try {
                // 模拟任务耗时
                Thread.sleep(1000);  // 线程休眠1秒
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
public class TestRunnable {
    public static void main(String[] args) {
        // 3. 创建RunnableThread实例
        RunnableThread runnableTask = new RunnableThread();
        // 4. 将Runnable实例传递给Thread对象
        Thread thread1 = new Thread(runnableTask, "线程1");
        Thread thread2 = new Thread(runnableTask, "线程2");
        // 5. 启动线程
        thread1.start();
        thread2.start();
    }
}
```

![image-20241026215709201](https://typora-xubang.oss-cn-hangzhou.aliyuncs.com/2024_xubang/image-20241026215709201.png?AI_make_money=VX_AI19858122061)

##### （3）实现Callable接口

​	1.实现 Callable 接口，并重写 call() 方法。

​	2.使用 FutureTask 来封装 Callable 实例。

​	3.创建一个 Thread，并传递 FutureTask 对象。

​	4.启动线程，并通过 FutureTask 的 get() 方法获取返回结果。

```java
package com.zdf.flowsvr.test.multiThread;

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

class CallableTask implements Callable<Integer> {
    // 1. 实现Callable接口并重写call方法
    @Override
    public Integer call() throws Exception {
        int sum = 0;
        for (int i = 1; i <= 5; i++) {
            sum += i;
            System.out.println(Thread.currentThread().getName() + " 正在计算，i = " + i);
            Thread.sleep(500);  // 模拟任务耗时
        }
        return sum;  // 返回计算结果
    }
}

public class TestCallable {
    public static void main(String[] args) {
        // 2. 创建CallableTask实例
        CallableTask callableTask = new CallableTask();
        // 3. 将Callable实例封装到FutureTask中
        FutureTask<Integer> futureTask = new FutureTask<>(callableTask);
        // 4. 使用Thread类来执行FutureTask
        Thread thread = new Thread(futureTask, "线程1");
        thread.start();
        try {
            // 5. 获取任务执行的结果
            Integer result = futureTask.get();  // 这是阻塞的，直到任务完成
            System.out.println("计算结果是：" + result);
        } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
        }
    }
}
```

![image-20241026220424818](https://typora-xubang.oss-cn-hangzhou.aliyuncs.com/2024_xubang/image-20241026220424818.png?AI_make_money=VX_AI19858122061)

我们知道：Thread、Runnable都是执行之后，不返回结果。如果想要线程执行完后可以返回结果，那么就可以使用Callable接口，也可以使用：Future和FutureTask接口。

###### 1.Future接口

Future 是一个用于表示异步计算结果的接口，提供了获取任务结果的方法。通常配合 Callable 使用，可以在任务执行完毕后通过 Future 对象获取结果。

关键方法：

```JAVA
public interface Future<V> {
    boolean cancel(boolean mayInterruptIfRunning);
    boolean isCancelled();
    boolean isDone();
    V get() throws InterruptedException, ExecutionException;
    V get(long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}
```

- get()：获取任务执行的结果，会阻塞直到任务完成。
- isDone()：检查任务是否完成。
- cancel()：取消任务的执行。
- isCancelled()：检查任务是否已被取消。

```JAVA
import java.util.concurrent.*;

public class FutureExample {
    public static void main(String[] args) {
        // 创建线程池
        ExecutorService executorService = Executors.newSingleThreadExecutor();

        // 提交 Callable 任务并返回 Future 对象
        Future<Integer> future = executorService.submit(() -> {
            int sum = 0;
            for (int i = 1; i <= 10; i++) {
                sum += i;
            }
            return sum;
        });

        try {
            // 阻塞获取任务结果
            Integer result = future.get();
            System.out.println("任务执行结果: " + result);
        } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
        }

        // 关闭线程池
        executorService.shutdown();
    }
}
```

###### 2.FutureTask接口

FutureTask 实现了 Runnable 和 Future 接口，既可以作为 Runnable 被线程执行，又可以作为 Future 获取任务的执行结果。FutureTask 适合需要手动创建线程时的使用场景。

使用方式：

- 将 Callable 或 Runnable 任务封装成 FutureTask 对象。
- 通过 Thread 或线程池执行 FutureTask。
- 通过 FutureTask 的 get() 方法获取结果。

```JAVA
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

public class FutureTaskExample {
    public static void main(String[] args) {
        // 创建 Callable 实例
        Callable<Integer> callableTask = () -> {
            int sum = 0;
            for (int i = 1; i <= 10; i++) {
                sum += i;
            }
            return sum;
        };

        // 封装 Callable 到 FutureTask
        FutureTask<Integer> futureTask = new FutureTask<>(callableTask);

        // 使用 Thread 执行 FutureTask
        Thread thread = new Thread(futureTask);
        thread.start();

        try {
            // 获取任务执行结果
            Integer result = futureTask.get();
            System.out.println("任务执行结果: " + result);
        } catch (InterruptedException | ExecutionException e) {
            e.printStackTrace();
        }
    }
}
```

##### （4）使用线程池

除了上述三种创建方式，其实还有一种就是通过线程池的方式创建线程。 Executors.newFixedThreadPool可以直接创建线程实例executorService，executorService.submit(()->{方法执行体}); 执行具体的任务。

最后，通过shutdown等待所有任务完成后，关闭线程池。

通过线程池创建线程，一方面可以保证线程的复用，避免了频繁的创建和销毁，降低了系统开销；另一方面可以保证控制线程创建的数量，控制最大并发数，避免过渡消耗系统资源；最后，也支持管理和监控任务的状态。

```java
package com.zdf.flowsvr.test.multiThread;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class ThreadPool{
    public static void main(String[] args) {
        // 1. 创建一个固定大小为3的线程池
        ExecutorService executorService = Executors.newFixedThreadPool(3);

        // 2. 提交多个任务给线程池执行
        for (int i = 1; i <= 5; i++) {
            final int taskId = i;
            executorService.submit(() -> {()
                System.out.println("任务 " + taskId + " 开始执行 by " + Thread.currentThread().getName());
                try {
                    // 模拟任务执行耗时
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("任务 " + taskId + " 执行完毕 by " + Thread.currentThread().getName());
            });
        }

        // 3. 关闭线程池，等待所有任务完成后终止
        executorService.shutdown();
    }
}
```

![image-20241026224123522](https://typora-xubang.oss-cn-hangzhou.aliyuncs.com/2024_xubang/image-20241026224123522.png?AI_make_money=VX_AI19858122061)



#### 5.Java中的interrupted和isInterrupted方法的区别？

在Java中，interrupted() 和 isInterrupted() 都是用于检测线程的中断状态，但它们有着显著的区别：

1. interrupted()

**作用**：interrupted() 是一个**静态方法**，用于检查**当前线程**是否被中断。

**清除中断状态**：调用 interrupted() 后会**清除当前线程的中断状态**。换句话说，每次调用它后，如果线程被中断过，中断状态会被复位为“未中断”。

**适用场景**：常用于在循环中检测中断状态，同时将中断状态清除，以便后续继续处理中断信号。

```java
public class InterruptedExample {
    public static void main(String[] args) {
        Thread thread = new Thread(() -> {
            while (true) {
                if (Thread.interrupted()) { // 检查并清除中断状态
                    System.out.println("线程被中断，退出循环");
                    break;
                }
            }
        });
        
        thread.start();
        
        // 主线程中断子线程
        thread.interrupt();
    }
}
```

在这个例子中，Thread.interrupted() 用于检查当前线程的中断状态，同时清除中断标志。因此在子线程中，检测到中断后退出循环。

2. isInterrupted()

**作用**：isInterrupted() 是**实例方法**，用于检查调用该方法的线程对象的**中断状态**，而不影响当前线程。

**不清除中断状态**：调用 isInterrupted() 不会清除线程的中断状态，之后可以多次调用以确认中断状态。

**适用场景**：适合在某个线程的外部检查该线程是否被中断，而不改变其中断状态。特别适用于监控线程的状态。

```java
public class IsInterruptedExample {
    public static void main(String[] args) {
        Thread thread = new Thread(() -> {
            while (!Thread.currentThread().isInterrupted()) { // 检查中断状态，但不清除
                System.out.println("线程正在运行...");
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    System.out.println("线程在sleep中被中断");
                    Thread.currentThread().interrupt(); // 再次设置中断状态
                }
            }
            System.out.println("线程已终止");
        });

        thread.start();

        // 主线程中断子线程
        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        thread.interrupt();
    }
}
```

在这个例子中，Thread.currentThread().isInterrupted() 检查当前线程的中断状态，但不清除它。即使线程被中断，中断标志仍然保留，使得线程可以在后续继续判断是否处于中断状态。

![image-20241026225358717](https://typora-xubang.oss-cn-hangzhou.aliyuncs.com/2024_xubang/image-20241026225358717.png?AI_make_money=VX_AI19858122061)

选择使用哪个方法，取决于是否希望清除中断状态。如果需要清除，可以使用 interrupted()；如果只是单纯检查某个线程的中断状态而不改变它，可以使用 isInterrupted()。



#### 6.线程之间如何通信及线程之间如何同步？

线程之间的通信机制有两种：共享内存和消息传递。

##### （1）线程之间的通信

线程之间的通信主要是指：多个线程之间共享数据，通常是一个线程通知另一个线程状态发生变化，从而保证后续的操作可以正常执行。

使用wait()、notify()、notifyAll()

Java的 Object 类提供了 wait()、notify() 和 notifyAll() 三个方法来实现线程间的通信。通常这三个方法需要和 synchronized 一起使用，以确保线程获取到对象锁后才能调用这些方法。

- wait()：使当前线程进入等待状态，直到其他线程调用 notify() 或 notifyAll() 唤醒该线程。

- notify()：唤醒一个等待中的线程，哪个线程被唤醒取决于JVM的实现。

- notifyAll()：唤醒所有等待的线程。

```java
package com.zdf.flowsvr.test.multiThread.ThreadModel;

public class ProducerConsumerExample {

    public static void main(String[] args) {
        Data data = new Data();

        // 生产者线程
        Thread producer = new Thread(() -> {
            for (int i = 0; i < 5; i++) {
                try {
                    data.produce(i);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });

        // 消费者线程
        Thread consumer = new Thread(() -> {
            for (int i = 0; i < 5; i++) {
                try {
                    data.consume();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        });

        producer.start();
        consumer.start();
    }
}

class Data {
    private int value;
    private boolean hasData = false;

    public synchronized void produce(int value) throws InterruptedException {
        while (hasData) {
            wait(); // 等待数据被消费
        }
        this.value = value;
        hasData = true;
        System.out.println("Produced: " + value);
        notify(); // 唤醒消费线程
    }

    public synchronized int consume() throws InterruptedException {
        while (!hasData) {
            wait(); // 等待数据被生产
        }
        hasData = false;
        System.out.println("Consumed: " + value);
        notify(); // 唤醒生产线程
        return value;
    }
}
```

![image-20241026232816150](https://typora-xubang.oss-cn-hangzhou.aliyuncs.com/2024_xubang/image-20241026232816150.png?AI_make_money=VX_AI19858122061)

使用Condition进行线程通信

Condition 是 java.util.concurrent 包中的类，可以和 Lock 一起实现线程通信。相比 wait() 和 notify() 更加灵活，适合复杂的线程通信需求。

```java
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

class DataWithCondition {
    private int value;
    private boolean hasData = false;
    private final Lock lock = new ReentrantLock();
    private final Condition condition = lock.newCondition();

    public void produce(int value) throws InterruptedException {
        lock.lock();
        try {
            while (hasData) {
                condition.await();
            }
            this.value = value;
            hasData = true;
            System.out.println("Produced: " + value);
            condition.signal();
        } finally {
            lock.unlock();
        }
    }

    public int consume() throws InterruptedException {
        lock.lock();
        try {
            while (!hasData) {
                condition.await();
            }
            hasData = false;
            System.out.println("Consumed: " + value);
            condition.signal();
            return value;
        } finally {
            lock.unlock();
        }
    }
}
```

##### （2）线程之间的同步

线程同步主要是为了防止多个线程访问共享资源而出现数据不一致的一个机制，一般可以使用：synchronized隐式锁和ReentrantLock、Lock等显式锁。

- synchronized

​	•	**同步方法**：在方法上加 synchronized，锁定当前对象的实例方法。

​	•	**同步代码块**：在代码块上加 synchronized，灵活地锁定指定对象。

```java
public class Counter {
    private int count = 0;

    // 同步方法
    public synchronized void increment() {
        count++;
    }

    // 同步代码块
    public void safeIncrement() {
        synchronized (this) {
            count++;
        }
    }

    public int getCount() {
        return count;
    }
}
```

- **使用 ReentrantLock 显示锁**

ReentrantLock 提供了比 synchronized 更高级的锁机制，支持中断、非阻塞获取锁、超时等待等功能。

```java
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class ReentrantLockExample {
    private final Lock lock = new ReentrantLock();
    private int count = 0;

    public void increment() {
        lock.lock();
        try {
            count++;
        } finally {
            lock.unlock(); // 确保锁的释放
        }
    }

    public int getCount() {
        return count;
    }
}
```

-  **使用 Atomic 变量**

在某些情况下，可以使用 AtomicInteger 等原子变量来实现线程安全的数值操作，避免使用锁。

```java
import java.util.concurrent.atomic.AtomicInteger;

public class AtomicExample {
    private final AtomicInteger count = new AtomicInteger(0);

    public void increment() {
        count.getAndIncrement(); // 原子操作
    }

    public int getCount() {
        return count.get();
    }
}
```

#### 7.什么是ThreadLocal？介绍一下ThreadLocal

ThreadLocal 作为线程变量，主要用于线程之间数据的隔离。每一个线程都有自己独有的一个ThreadLocal。在执行过程中，每个线程可以通过get方法从ThreadLocal中获取对应的变量，或者通过set方法修改定义内部的变量。ThreadLocal的存储方式是以键值对的形式进行存储，键是ThreadLocal对象本身，值可以是任意的其他对象。

#### 8.为什么ThreadLocal会造成内存泄漏？如何解决？

ThreadLocal 会为每个线程单独维护一个变量副本，存储在 Thread 对象内部的 ThreadLocalMap 中。这个 ThreadLocalMap 的 key 是 ThreadLocal 实例，value 是实际存储的数据对象。

```JAVA
public class ThreadLocal<T> {
  static class ThreadLocalMap {
          /**
           * The entries in this hash map extend WeakReference, using
           * its main ref field as the key (which is always a
           * ThreadLocal object).  Note that null keys (i.e. entry.get()
           * == null) mean that the key is no longer referenced, so the
           * entry can be expunged from table.  Such entries are referred to
           * as "stale entries" in the code that follows.
           */
          static class Entry extends WeakReference<ThreadLocal<?>> {
              /** The value associated with this ThreadLocal. */
              Object value;

              Entry(ThreadLocal<?> k, Object v) {
                  super(k);
                  value = v;
              }
          }
    ... 
  }
}
```

由于 ThreadLocalMap 使用的是弱引用（WeakReference）来引用 ThreadLocal 实例，而不是强引用，这意味着当 ThreadLocal 本身不再被外部强引用引用时，GC 会回收该 ThreadLocal 对象。但即使 ThreadLocal 被回收，其对应的 value 仍然保留在 ThreadLocalMap 中。这就造成了一个问题——这些对象在没有手动清除的情况下将一直保留在 ThreadLocalMap 中，从而导致内存泄漏。

如果使用了线程池（如 Executors.newFixedThreadPool() 创建的线程池），线程会被长时间或永久复用，而不是正常结束。由于 ThreadLocal 的生命周期与线程生命周期挂钩，这些线程池线程的 ThreadLocalMap 中的 value 也会一直保留在内存中，造成内存泄漏。

在使用ThreadLocal中，我们要避免在全局或者长生命周期中使用ThreadLocal，即便使用，也要记得使用remove进行手动清除。

#### 9.线程的基本用法

![image-20241027160040748](https://typora-xubang.oss-cn-hangzhou.aliyuncs.com/2024_xubang/image-20241027160040748.png?AI_make_money=VX_AI19858122061)



